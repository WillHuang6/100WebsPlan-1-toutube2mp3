import { NextRequest, NextResponse } from 'next/server';
import { spawn } from 'child_process';
import os from 'os';
import fs from 'fs';
import path from 'path';

// ğŸ©º ç³»ç»Ÿå¥åº·æ£€æŸ¥ API
export async function GET(req: NextRequest) {
  const startTime = Date.now();
  
  try {
    const healthData = {
      timestamp: new Date().toISOString(),
      system: await getSystemInfo(),
      tools: await checkToolsAvailability(),
      performance: await getPerformanceMetrics(),
      storage: await getStorageInfo(),
      status: 'healthy'
    };
    
    const totalTime = Date.now() - startTime;
    healthData.performance.healthCheckTime = totalTime;
    
    return NextResponse.json(healthData);
  } catch (error) {
    return NextResponse.json({
      timestamp: new Date().toISOString(),
      status: 'unhealthy',
      error: (error as Error).message,
      healthCheckTime: Date.now() - startTime
    }, { status: 500 });
  }
}

// ğŸ“Š ç³»ç»Ÿä¿¡æ¯
async function getSystemInfo() {
  return {
    platform: os.platform(),
    arch: os.arch(),
    nodeVersion: process.version,
    cpuCores: os.cpus().length,
    totalMemory: Math.round(os.totalmem() / 1024 / 1024 / 1024 * 100) / 100, // GB
    freeMemory: Math.round(os.freemem() / 1024 / 1024 / 1024 * 100) / 100, // GB
    loadAverage: os.loadavg(),
    uptime: os.uptime()
  };
}

// ğŸ”§ å·¥å…·å¯ç”¨æ€§æ£€æŸ¥
async function checkToolsAvailability() {
  const tools = {
    ytdlp: false,
    ffmpeg: false,
    versions: {} as Record<string, string>
  };
  
  // æ£€æŸ¥ yt-dlp
  try {
    const ytdlpVersion = await execCommand('yt-dlp', ['--version']);
    tools.ytdlp = true;
    tools.versions.ytdlp = ytdlpVersion.trim();
  } catch (error) {
    console.error('yt-dlp ä¸å¯ç”¨:', error);
  }
  
  // æ£€æŸ¥ ffmpeg
  try {
    const ffmpegVersion = await execCommand('ffmpeg', ['-version']);
    tools.ffmpeg = true;
    const versionMatch = ffmpegVersion.match(/ffmpeg version (\S+)/);
    tools.versions.ffmpeg = versionMatch ? versionMatch[1] : 'unknown';
  } catch (error) {
    console.error('ffmpeg ä¸å¯ç”¨:', error);
  }
  
  return tools;
}

// ğŸ“ˆ æ€§èƒ½æŒ‡æ ‡
async function getPerformanceMetrics() {
  const metrics = {
    memoryUsage: process.memoryUsage(),
    cpuUsage: process.cpuUsage(),
    eventLoopDelay: 0,
    processUptime: process.uptime()
  };
  
  // ç®€å•çš„äº‹ä»¶å¾ªç¯å»¶è¿Ÿæµ‹è¯•
  const start = Date.now();
  await new Promise(resolve => setImmediate(resolve));
  metrics.eventLoopDelay = Date.now() - start;
  
  return metrics;
}

// ğŸ’¾ å­˜å‚¨ä¿¡æ¯
async function getStorageInfo() {
  const tempPath = path.join(process.cwd(), 'public', 'temp');
  
  let fileCount = 0;
  let totalSize = 0;
  
  try {
    if (fs.existsSync(tempPath)) {
      const files = fs.readdirSync(tempPath);
      fileCount = files.length;
      
      for (const file of files) {
        const filePath = path.join(tempPath, file);
        const stats = fs.statSync(filePath);
        totalSize += stats.size;
      }
    }
  } catch (error) {
    console.error('è¯»å–å­˜å‚¨ä¿¡æ¯å¤±è´¥:', error);
  }
  
  return {
    tempPath,
    fileCount,
    totalSize: Math.round(totalSize / 1024 / 1024 * 100) / 100, // MB
    diskSpace: await getDiskSpace()
  };
}

// ğŸ’½ ç£ç›˜ç©ºé—´æ£€æŸ¥
async function getDiskSpace() {
  try {
    if (os.platform() === 'darwin' || os.platform() === 'linux') {
      const output = await execCommand('df', ['-h', '.']);
      const lines = output.split('\n');
      if (lines.length > 1) {
        const parts = lines[1].split(/\s+/);
        return {
          total: parts[1],
          used: parts[2],
          available: parts[3],
          usePercent: parts[4]
        };
      }
    }
  } catch (error) {
    console.error('è·å–ç£ç›˜ç©ºé—´å¤±è´¥:', error);
  }
  
  return null;
}

// ğŸ”¨ æ‰§è¡Œå‘½ä»¤è¾…åŠ©å‡½æ•°
function execCommand(command: string, args: string[]): Promise<string> {
  return new Promise((resolve, reject) => {
    const process = spawn(command, args);
    let output = '';
    let error = '';
    
    process.stdout.on('data', (data) => {
      output += data.toString();
    });
    
    process.stderr.on('data', (data) => {
      error += data.toString();
    });
    
    process.on('close', (code) => {
      if (code === 0) {
        resolve(output);
      } else {
        reject(new Error(`å‘½ä»¤æ‰§è¡Œå¤±è´¥: ${command} ${args.join(' ')}\n${error}`));
      }
    });
    
    process.on('error', (err) => {
      reject(err);
    });
    
    // 5ç§’è¶…æ—¶
    setTimeout(() => {
      process.kill('SIGTERM');
      reject(new Error('å‘½ä»¤æ‰§è¡Œè¶…æ—¶'));
    }, 5000);
  });
}